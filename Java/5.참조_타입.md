# 5. 참조 타입
## 5.1 데이터 타입 분류  
2장에서 기본 타입에 대해서 알아보았으니, 이번 장에서는 참조 타입에 대해 알아보자.  
> 참조 타입: 객체의 번지를 참조하는 타입으로 배열, 열거, 클래스, 인터페이스 타입이 있다.  
객체 = 데이터(필드) + 메소드 (자세한 것은 6장에서 다룸.)

![](https://velog.velcdn.com/images%2Fjakeseo_me%2Fpost%2Fa49bb01f-95c6-40f1-bb31-76888db95b63%2Fimage.png)  

![](https://velog.velcdn.com/images/jwpark1104/post/ab314975-315e-468d-b885-74a64b97f773/image.PNG)  

- 변수들은 스택이라는 메모리 영역에 생성됨
- 기본 타입으로 선언된 변수 -> 값 자체를 직접 저장
- 참조 타입으로 선언된 변수 -> 객체가 생성된 메모리 번지를 저장. 객체는 힙 메모리 영역에 생성됨

## 5.2 메모리 사용 영역  
JVM이 운영체제에서 할당받은 메모리 영역 즉, 자바에서 사용하는 메모리 영역에 대해 간단히 알아보자.  

![](https://velog.velcdn.com/images%2Fjakeseo_me%2Fpost%2F9d9016cc-5ff3-408d-9f67-3def03d508a0%2Fimage.png)  

**메소드 영역**  
바이트코드 파일을 읽은 내용이 저장되는 영역  
클래스별로 상수, 정적 필드, 메소드 코드, 생성자 코드 등이 저장된다. 아직 이 용어들은 몰라도 상관없다.

**힙 영역**  
객체가 생성되는 영역  
객체의 번지는 메소드 영역의 상수와 변수에서 참조할 수 있다.

**스택 영역**  
메소드를 호출할 때마다 생성되는 프레임이 저장되는 영역  
메소드 호출이 끝나면 프레임은 자동 제거된다. 프레임 내부에는 로컬 변수 스택이 있다. 여기에서 기본 타입 변수와 참조 타입 변수가 생성되고 제거된다.  

## 5.3 참조 타입 변수의 ==, != 연산  
`==`, `!=` 연산자: 변수의 값이 같은지 아닌지 조사.  
참조 타입 변수의 값은 객체의 번지이므로 참조 타입 변수에서는 번지를 비교하는 것이 된다.

```java
public class ReferenceVariableCompareExample {
    public static void main(String[] args) {
        //배열 {1, 2, 3}을 힙에 생성하고 arr1에 번지 대입
        int[] arr1 = {1, 2, 3};
        int[] arr2 = {1, 2, 3};
        //arr2 값(배열 번지)를 arr3 에 대입
        int[] arr3 = arr2;

        System.out.println(arr1 == arr2); //값만 같고 번지는 다름. 서로 다른 배열 객체 -> false
        System.out.println(arr1 != arr2); //서로 같은 배열 객체 -> true
    }
}
```   

## 5.4 null과 NullPointerException
**null**  
참조 타입 변수는 '아직 번지를 저장하고 있지 않다'는 뜻으로 null 값을 가질 수 있다.  
참조 타입 변수가 null 값을 가지는지 확인하려면 ==, != 연산을 수행할 수 있다.  
`var1 == null`  
`var2 != null`

**NullPointerException**
> 예외: 프로그램 실행 도중에 발생하는 오류  

NullPointerException: 변수가 null인 상태에서 객체의 데이터나 메소드를 사용하려 할 때 발생하는 예외. 참조 변수를 사용하면서 가장 많이 발생하는 예외 중 하나.  

```java
String str = null;        
//str 변수가 참조하는 String 객체가 없으므로 길이 구할 수 없음
System.out.println(str.length);  //NullPointerException
```

**null을 의도적으로 대입하는 경우**  
null을 의도적으로 대입하는 이유는 객체를 제거하기 위해서이다.  
```java
String hobby = "여행";
hobby = null;  //"여행"객체가 쓰레기가 됨

int[] kind1 = {1, 2, 3};
int[] kind2 = kind1;
kind1 = null;  //"{1, 2, 3}" 객체는 여전히 kind2 변수가 참조하고 있으므로 쓰레기가 되지 않음.
```
위의 `여행` 처럼 어떤 변수에서도 객체를 참조하지 않으면 해당 객체는 힙 메모리에 존재하지만 위치 정보를 알 수 없으므로, 프로그램에서 사용할 수 없게 된다. 자바는 이러한 객체를 쓰레기로 취급하고, 쓰레기 수집기를 실행시켜 자동으로 제거한다.  
자바는 객체를 직접 제거하는 코드를 제공하지 않으므로, 객체를 제거하는 유일한 방법은 객체의 뫄든 참조를 없애는 것이다.

## 5.5 문자열(String) 타입 (클래스 타입)
### 문자열 비교
자바는 문자열 리터럴이 동일하다면 String 객체를 공유하도록 설계되어 있다.  
new 연산자는 새로운 객체를 Heap이라는 메모리 영역에 메모리 공간을 할당해주고, 메모리주소를 반환해주는 객체 생성 연산자이다. 
```java
String a = "가";
String b = "가";
System.out.println(a == b);  //true: 서로 같은 번지

String c = "가";
String d = new String("가");
System.out.println(c == d);  //false: 서로 다른 번지
```

String 객체의 번지가 동일하든 아니든 상관없이 내부 문자열을 비교할 경우 String 객체의 `equals()` 메소드를 사용한다.  

```java
String c = "가";
String d = new String("가");
boolean result1 = c.equals(d); //문자열이 같은지 검사(대소문자 구분)

//String 변수에 빈 문자열을 대입할 수도 있다. 빈 문자열도 객체로 생성되기 때문.
String hobby = "";
boolean result3 = hobby.eqauls(""); //true
```
### 문자 추출
`charAt()` 메소드: 문자열에서 특정 위치의 문자를 얻고 싶을 때 사용
```java
String a = "자바 프로그래밍";
//자-0, 바-1, ""-2, 프-3, 로-4, 그-5, 래-6, 밍-7
char charValue = a.charAt(3); //"프"
```
### 문자열 길이
`length()` 메소드: 문자열에서 문자의 개수를 얻고 싶을 때 사용
```java
String a = "자바 프로그래밍";
int length = a.length();  //8(공백 포함 문자열 길이)
```
### 문자열 대체
`replace(a, b)` 메소드: 문자열에서 특정 문자열(a)을 다른 문자열(b)로 대체하고 싶을 때 사용.  
기존 문자열은 그대로 두고, 대체한 새로운 문자열을 리턴한다.
```java
String oldStr = "자바 프로그래밍";
String newStr = oldstr.replace("자바", "JAVA");
System.out.prinln(oldStr);  //자바 프로그래밍
System.out.prinln(newStr);  //JAVA 프로그래밍
```
### 문자열 잘라내기
`substring()` 메소드: 문자열에서 특정 위치의 문자열을 잘라내어 가져오고 싶을 때 사용  
`substring(int beginIndex)`: beginIndex 에서 끝까지  
`substring(int beginIndex, int endIndex)`: beginIndex 에서 endIndex 앞까지
```java
String ssn = "980212-2222222";
String first = ssn.substring(0, 6);  //980212
String second = ssn.substring(7);    //2222222
```
### 문자열 찾기
`indexOf()` 메소드: 문자열에서 특정 문자열의 위치를 찾고자 할 때. 주어진 문자열이 시작되는 인덱스를 리턴. 주어진 문자열이 포함되어 있지 않으면 -1을 리턴.

`contains()` 메소드: 문자열에서 주어진 문자열이 단순히 포함되어 있는지 확인하고자 할 때. (true/false)
```java
String sub = "자바 프로그래밍";
int index =sub.indexOf("프로그래밍");        //3
boolean result = sub.contains("프로그래밍"); //true
```
### 문자열 분리
`split()` 메소드: 문자열이 구분자를 사용하여 여러 개의 문자열로 구성되어 있을 경우, 이를 따로 분리해서 얻고 싶을 때
```java
String board = "번호,제목,내용,글쓴이";
String[] arr = board.split(",") //arr={"번호", "제목", "내용", "글쓴이"}
```

## 5.6 배열(Array) 타입
- 배열은 같은 타입의 값만 관리한다.
- 배열의 길이는 늘리거나 줄일 수 없다.

### 배열 변수 선언
`타입[] 변수;`    
`타입 변수[];`  
배열 변수 선언은 위와 같이 두 가지 형태로 작성할 수 있지만, 관례적으로 첫 번째 방법을 주로 사용한다.

### 값 목록으로 배열 생성
중괄호 {}는 나열된 값들을 항목으로 가지는 배열을 힙에 생성하고, 번지를 리턴한다. 배열 변수는 리턴된 번지를 저장함으로써 참조가 이루어진다.  
`int[] scores = {10, 20, 30};`   

![](https://user-images.githubusercontent.com/37354733/100700159-274d4b80-33e0-11eb-89ea-aed6e1e30669.png)  

중괄호 {}로 감싼 값의 목록을 배열 변수에 대입할 때 주의할 점이 있다.  
**배열 변수를 미리 선언한 후에는 값 목록을 변수에 대입할 수 없다.** 배일 변수를 선언한 시점과 값 목록이 대입되는 시점이 다르다면 다음과 같이 `new 타입[]`을 중괄호 앞에 붙여주면 된다. 타입은 배열 변수를 선언할 때 사용한 타입과 동일해야 한다.  
```java
int[] arr = null;
arr = {1, 2, 3};  //컴파일 에러
arr = new int[] {1, 2, 3};
```

#### 메소드의 매개변수가 배열 타입일 경우   
메소드의 매개변수가 배열 타입일 경우에도 마찬가지다. 
메소드의 매개변수가 이미 선언되어 있고, 호출 시 값 목록을 제공하므로 new 연산자를 사용하여 호출해야 한다.

```java
//메소드 선언
void printItem(int[] scores) {...}

//잘못된 메소드 호출
printItem({95, 80, 87});  //컴파일 에러

//올바른 메소드 호출
printItem(new int[] {95, 80, 97});
```

### new 연산자로 배열 생성
값의 목록은 없지만 향후 값들을 저장할 목적으로 기본값으로 초기화된 배열을 미리 생성할 수 있다.  
`타입[] 변수 = new 타입[길이];`   

![](https://velog.velcdn.com/images%2Fmmy789%2Fpost%2F95e9e52f-359e-411e-b2ab-911f590d85cf%2Fimage.png)

```java
double[] arr = new double[3];  //arr {0.0, 0.0, 0.0}
arr[0] = 0.1;
arr[1] = 0.2;
arr[2] = 0.3;
System.out.println(arr);       //arr {0.1, 0.2, 0.3}
```

### 배열 길이  
배열의 길이를 얻으려면 도트(.) 연산자를 사용해서 참조하는 배열의 length 필드를 읽으면 된다.  
`배열변수.length`  
```java
int[] scores = {82, 91, 97};

int sum = 0;
for(int i=0; i<scores.length, i++) {
    sum += scores;  //sum 270
}
double avg = (double)sum / scores.length;
System.out.println("평균: " + avg);   //평균: 90
```

## 5.7 다차원 배열


## 5.8 객체를 참조하는 배열


## 5.9 배열 복사


## 5.10 배열 항목 반복을 위한 향상된 for 문


## main() 메소드의 String[] 매개변수 용도


## 5.12 열거(Enum) 타입
