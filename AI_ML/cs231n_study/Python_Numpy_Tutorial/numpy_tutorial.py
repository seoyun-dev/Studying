# Numpy는 고성능의 다차원 배열 객체와 이를 다룰 도구를 제공
import numpy as np

# NOTE 배열
# rank: 배열이 몇 차원인지 ([]개수)
# shape: 각 차원의 크기를 알려주는 정수들이 모인 튜플
a = np.array([1, 2, 3])     # rank가 1인 배열 생성
print (type(a))            # 출력 "<type 'numpy.ndarray'>"
print (a.shape)            # 출력 "(3,)"
b = np.array([[1,2,3],[4,5,6]])     # rank가 2인 배열 생성
print (b.shape)                     # 출력 "(2, 3)"
print (b[0, 0], b[0, 1], b[1, 0])   # 출력 "1 2 4"

a = np.zeros((2,2))  # 모든 값이 0인 배열 생성
print (a)              # 출력 "[[ 0.  0.]
                    #       [ 0.  0.]]"
b = np.ones((1,2))   # 모든 값이 1인 배열 생성
print (b)              # 출력 "[[ 1.  1.]]"
c = np.full((2,2), 7) # 모든 값이 특정 상수인 배열 생성
print (c)               # 출력 "[[ 7.  7.]
                    #       [ 7.  7.]]"
d = np.eye(2)        # 2x2 단위행렬 생성, np.eye(n, 대각성분 값)(n->n*n행렬)
print (d)              # 출력 "[[ 1.  0.]
                    #       [ 0.  1.]]"
e = np.random.random((2,2)) # 임의의 값으로 채워진 배열 생성
print (e)                     # 임의의 값 출력 "[[ 0.91940167  0.08143941]
                            #                  [ 0.68744134  0.87236687]]"



# NOTE 배열 인덱싱
# Create the following rank 2 array with shape (3, 4)
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# 슬라이싱을 이용하여 첫 두 행과 1열, 2열로 이루어진 부분배열을 만들어 봅시다;
# b는 shape가 (2,2)인 배열이 됩니다:
# [[2 3]
#  [6 7]]
b = a[:2, 1:3]

# 슬라이싱된 배열은 원본 배열과 같은 데이터를 참조합니다, 즉 슬라이싱된 배열을 수정하면
# 원본 배열 역시 수정됩니다.
print (a[0, 1])   # 출력 "2"
b[0, 0] = 77    # b[0, 0]은 a[0, 1]과 같은 데이터입니다
print (a[0, 1])   # 출력 "77"

# 아래와 같은 요소를 가지는 rank가 2이고 shape가 (3, 4)인 배열 생성
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

# 배열의 중간 행에 접근하는 두 가지 방법이 있습니다.
# 정수 인덱싱과 슬라이싱을 혼합해서 사용하면 낮은 rank의 배열이 생성되지만,
# 슬라이싱만 사용하면 원본 배열과 동일한 rank의 배열이 생성됩니다.
row_r1 = a[1, :]    # 배열a의 두 번째 행을 rank가 1인 배열로
row_r2 = a[1:2, :]  # 배열a의 두 번째 행을 rank가 2인 배열로
print (row_r1, row_r1.shape)  # 출력 "[5 6 7 8] (4,)"
print (row_r2, row_r2.shape)  # 출력 "[[5 6 7 8]] (1, 4)"

# 행이 아닌 열의 경우에도 마찬가지입니다:
col_r1 = a[:, 1]
col_r2 = a[:, 1:2]
print (col_r1, col_r1.shape)  # 출력 "[ 2  6 10] (3,)"
print (col_r2, col_r2.shape)  # 출력 "[[ 2]
                            #       [ 6]
                            #       [10]] (3, 1)"



#NOTE 정수 배열 인덱싱
a = np.array([[1,2], [3, 4], [5, 6]])

# 정수 배열 인덱싱의 예.
# 반환되는 배열의 shape는 (3,)
print (a[[0, 1, 2], [0, 1, 0]])  # 출력 "[1 4 5]"
# 위에서 본 정수 배열 인덱싱 예제는 다음과 동일합니다:
print (np.array([a[0, 0], a[1, 1], a[2, 0]]))  # 출력 "[1 4 5]"

print ([a[0, 0], a[1, 1], a[2, 0]])
# 정수 배열 인덱싱을 사용할 때,
# 원본 배열의 같은 요소를 재사용할 수 있습니다:
print (a[[0, 0], [1, 1]])  # 출력 "[2 2]"
# 위 예제는 다음과 동일합니다
print (np.array([a[0, 1], a[0, 1]]))  # 출력 "[2 2]"

# 정수 배열 인덱싱을 유용하게 사용하는 방법 중 하나는 행렬의 각 행에서 하나의 요소를 선택하거나 바꾸는 것입니다:
# 요소를 선택할 새로운 배열 생성
a = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])

print(a)  # 출력 "array([[ 1,  2,  3],
            #             [ 4,  5,  6],
            #             [ 7,  8,  9],
            #             [10, 11, 12]])"
# 인덱스를 저장할 배열 생성
b = np.array([0, 2, 0, 1])
# b에 저장된 인덱스를 이용해 각 행에서 하나의 요소를 선택합니다
print (a[np.arange(4), b])  # 출력 "[ 1  6  7 11]"
# b에 저장된 인덱스를 이용해 각 행에서 하나의 요소를 변경합니다
a[np.arange(4), b] += 10
print (a)   # 출력 "array([[11,  2,  3],
            #             [ 4,  5, 16],
            #             [17,  8,  9],
            #             [10, 21, 12]]



# NOTE  불리언 배열 인덱싱
a = np.array([[1,2], [3, 4], [5, 6]])

bool_idx = (a > 2)  # 2보다 큰 a의 요소를 찾습니다;
                    # 이 코드는 a와 shape가 같고 불리언 자료형을 요소로 하는 numpy 배열을 반환합니다,
                    # bool_idx의 각 요소는 동일한 위치에 있는 a의
                    # 요소가 2보다 큰지를 말해줍니다.
print (bool_idx)      # 출력 "[[False False]
                        #       [ True  True]
                        #       [ True  True]]"
# 불리언 배열 인덱싱을 통해 bool_idx에서
# 참 값을 가지는 요소로 구성되는
# rank 1인 배열을 구성할 수 있습니다.
print (a[bool_idx])  # 출력 "[3 4 5 6]"
# 위에서 한 모든것을 한 문장으로 할 수 있습니다:
print (a[a > 2])     # 출력 "[3 4 5 6]"

# NOTE 자료형
x = np.array([1, 2])  # Numpy가 자료형을 추측해서 선택
print (x.dtype)         # 출력 "int64"
x = np.array([1.0, 2.0])  # Numpy가 자료형을 추측해서 선택
print (x.dtype)             # 출력 "float64"
x = np.array([1, 2], dtype=np.int64)  # 특정 자료형을 명시적으로 지정
print (x.dtype)                         # 출력 "int64



# NOTE 배열 연산
x = np.array([[1,2],[3,4]], dtype=np.float64)
y = np.array([[5,6],[7,8]], dtype=np.float64)
# 요소별 합; 둘 다 다음의 배열을 만듭니다
# [[ 6.0  8.0]
#  [10.0 12.0]]
print (x + y)
print (np.add(x, y))
# 요소별 차; 둘 다 다음의 배열을 만듭니다
# [[-4.0 -4.0]
#  [-4.0 -4.0]]
print (x - y)
print (np.subtract(x, y))
# 요소별 곱; 둘 다 다음의 배열을 만듭니다
# [[ 5.0 12.0]
#  [21.0 32.0]]
print (x * y)
print (np.multiply(x, y))
# 요소별 나눗셈; 둘 다 다음의 배열을 만듭니다
# [[ 0.2         0.33333333]
#  [ 0.42857143  0.5       ]]
print (x / y)
print (np.divide(x, y))
# 요소별 제곱근; 다음의 배열을 만듭니다
# [[ 1.          1.41421356]
#  [ 1.73205081  2.        ]]
print (np.sqrt(x))

# 벡터의 내적, 벡터와 행렬의 곱, 행렬곱을 위해 ‘‘대신 ‘dot’함수를 사용
x = np.array([[1,2],[3,4]])
y = np.array([[5,6],[7,8]])

v = np.array([9,10])
w = np.array([11, 12])

# 벡터의 내적; 둘 다 결과는 219
print (v.dot(w))
print (np.dot(v, w))

# 행렬과 벡터의 곱; 둘 다 결과는 rank 1인 배열 [29 67]
print (x.dot(v))
print (np.dot(x, v))

# 행렬곱; 둘 다 결과는 rank 2인 배열
# [[19 22]
#  [43 50]]
print (x.dot(y))
print (np.dot(x, y))

# sum
x = np.array([[1,2],[3,4]])
print (np.sum(x))  # 모든 요소를 합한 값을 연산; 출력 "10"
print (np.sum(x, axis=0))  # 각 열에 대한 합을 연산; 출력 "[4 6]"
print (np.sum(x, axis=1))  # 각 행에 대한 합을 연산; 출력 "[3 7]"

# 전치
x = np.array([[1,2], [3,4]])
print (x)    # 출력 "[[1 2]
            #          [3 4]]"
print (x.T)  # 출력 "[[1 3]
            #          [2 4]]"
# rank 1인 배열을 전치할 경우 아무 일도 일어나지 않습니다:
v = np.array([1,2,3])
print (v)    # 출력 "[1 2 3]"
print (v.T)  # 출력 "[1 2 3]"



# NOTE 브로드캐스팅: 브로트캐스팅은 Numpy에서 shape가 다른 배열 간에도 산술 연산이 가능하게 하는 메커니즘입니다. 종종 작은 배열과 큰 배열이 있을 때, 큰 배열을 대상으로 작은 배열을 여러 번 연산하고자 할 때가 있습니다. 예를 들어, 행렬의 각 행에 상수 벡터를 더하는 걸 생각해보세요. 이는 다음과 같은 방식으로 처리될 수 있습니다:
# Sol 1
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
vv = np.tile(v, (4, 1))     # v의 복사본 4개를 위로 차곡차곡 쌓은 것이 vv
print (vv)                  # 출력 "[[1 0 1]
                            #       [1 0 1]
                            #       [1 0 1]
                            #       [1 0 1]]"
y = x + vv  # x와 vv의 요소별 합
print (y)   # 출력 "[[ 2  2  4
            #       [ 5  5  7]
            #       [ 8  8 10]
            #       [11 11 13]]"
# Sol 2
# 벡터 v를 행렬 x의 각 행에 더한 뒤,
# 그 결과를 행렬 y에 저장하고자 합니다
x = np.array([[1,2,3], [4,5,6], [7,8,9], [10, 11, 12]])
v = np.array([1, 0, 1])
y = x + v  # 브로드캐스팅을 이용하여 v를 x의 각 행에 더하기
print (y)  # 출력 "[[ 2  2  4]
            #       [ 5  5  7]
            #       [ 8  8 10]
            #       [11 11 13]]"
# x의 shape가 (4, 3)이고 v의 shape가 (3,)라도 브로드캐스팅으로 인해 y = x + v는 문제없이 수행됩니다; 이때 ‘v’는 ‘v’의 복사본이 차곡차곡 쌓인 shape (4, 3)처럼 간주되어 ‘x’와 동일한 shape가 되며 이들 간의 요소별 덧셈연산이 y에 저장됩니다.